// bno-api/lib/mews.ts
import axios, { AxiosRequestConfig } from 'axios';

export type MewsClientOptions = {
  baseUrl: string;
  clientToken: string;
  accessToken: string;
  enterpriseId?: string;
  clientName: string;
  hotelTimeZone: string;
};

export type MewsClient = {
  toTimeUnitUtc: (date: string | Date) => string;
  parseIsoDurationToMs: (dur: string | undefined) => number | null;

  fetchAvailability: (serviceId: string, first: string | Date, last: string | Date) => Promise<any>;
  fetchAvailabilityNamed: (serviceId: string, first: string | Date, last: string | Date) => Promise<any>;
  fetchCategoriesRaw: (serviceId: string) => Promise<any[]>;
  fetchImageUrls: (imageIds: string[]) => Promise<Record<string, string>>;
  fetchProducts: (serviceId: string) => Promise<any[]>;
  fetchService: (serviceId: string) => Promise<any | null>;

  findOrCreateCustomer: (customer: any) => Promise<string>;
  createReservation: (p: any) => Promise<any>;
  createProductServiceOrders: (serviceId: string, reservationId: string, orders: any[]) => Promise<any>;

  fetchResources: (serviceId: string | string[]) => Promise<any[]>;
  fetchSpaces: (serviceId: string | string[]) => Promise<any[]>;

  fetchOrderItemsForCleaningRange: (
    serviceId: string | string[],
    startDate: string | Date,
    endDate: string | Date
  ) => Promise<any[]>;

  fetchReservationsForCleaningRange: (
    serviceId: string,
    startDate: string | Date,
    endDate: string | Date
  ) => Promise<any[]>;

  buildLinenCountMapFromOrderItems: (
    items: any[],
    linenProducts: Record<string, { personsPerUnit: number; name: string }>,
    soToRes?: Record<string, string> | Map<string, string>,
  ) => Record<string, number>;
};

// ===== Axios retry helper (429 Retry-After + transient errors) =====
async function axiosWithRetry<T = any>(
  config: AxiosRequestConfig,
  maxRetries = 3,
  initialDelayMs = 500,
  respectRetryAfter = true,
): Promise<T> {
  let attempt = 0;
  let delay = initialDelayMs;

  while (true) {
    try {
      const resp = await axios(config);
      return resp.data as T;
    } catch (err: any) {
      attempt++;
      const status = err?.response?.status;
      const headers = err?.response?.headers || {};
      const retryAfterRaw = headers['retry-after'];
      const code = err?.code || null;

      if (status === 429 && attempt <= maxRetries) {
        let waitMs = delay;

        if (respectRetryAfter && retryAfterRaw) {
          const asNum = Number(retryAfterRaw);
          if (!Number.isNaN(asNum)) {
            waitMs = asNum * 1000;
          } else {
            const parsed = Date.parse(retryAfterRaw);
            if (!Number.isNaN(parsed)) {
              const now = Date.now();
              const until = parsed - now;
              waitMs = until > 0 ? until : delay;
            }
          }
        }

        const maxCap = 10 * 60 * 1000;
        if (waitMs > maxCap) waitMs = maxCap;

        console.warn(`axiosWithRetry: 429 attempt ${attempt}, waiting ${waitMs}ms`);
        await new Promise((r) => setTimeout(r, waitMs));
        delay *= 2;
        continue;
      }

      const transientCodes = ['ECONNRESET', 'ECONNABORTED', 'ENOTFOUND', 'EAI_AGAIN'];
      if (transientCodes.includes(code) && attempt <= maxRetries) {
        console.warn(`axiosWithRetry: transient ${code}, attempt ${attempt}, retrying in ${delay}ms`);
        await new Promise((r) => setTimeout(r, delay));
        delay *= 2;
        continue;
      }

      const info = {
        message: err?.message,
        status,
        code,
        headers,
        data: err?.response?.data || null,
      };
      console.error('axiosWithRetry: giving up', info);

      const e = new Error(err?.message || 'Request failed');
      (e as any).response = err?.response || null;
      (e as any).mewsResponse = info;
      throw e;
    }
  }
}

// ---------- helpers ----------
function tzOffsetMinutesAt(utcInstant: Date, tz: string): number {
  try {
    const fmt = new Intl.DateTimeFormat('en-US', {
      timeZone: tz,
      timeZoneName: 'shortOffset',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false,
    });
    const parts = fmt.formatToParts(utcInstant);
    const tzName = parts.find((p) => p.type === 'timeZoneName')?.value || 'GMT+00:00';
    const m = tzName.match(/([+-])(\d{1,2})(?::?(\d{2}))?$/);
    if (!m) return 0;
    const sign = m[1] === '-' ? -1 : 1;
    const hh = parseInt(m[2], 10);
    const mm = m[3] ? parseInt(m[3], 10) : 0;
    return sign * (hh * 60 + mm);
  } catch {
    return 0;
  }
}

function removeUndefinedRecursive(obj: any): any {
  if (obj === null || obj === undefined) return undefined;
  if (Array.isArray(obj)) {
    const a = obj.map((v) => removeUndefinedRecursive(v)).filter((v) => v !== undefined);
    return a;
  }
  if (typeof obj === 'object') {
    const out: any = {};
    for (const k of Object.keys(obj)) {
      const rv = removeUndefinedRecursive((obj as any)[k]);
      if (rv !== undefined) out[k] = rv;
    }
    return Object.keys(out).length ? out : undefined;
  }
  return obj;
}

/** Navnesanitering (ASCII, minst 2 bokstaver) */
function sanitizeName(v: string | undefined): string {
  if (!v) return 'Guest';
  let s = String(v).trim();
  try {
    s = s.normalize('NFKD').replace(/[\u0300-\u036f]/g, '');
  } catch {}
  s = s.replace(/[^A-Za-z\s\-']/g, ' ').replace(/\s+/g, ' ').trim();
  if (s.replace(/[^A-Za-z]/g, '').length < 2) s = 'Guest';
  return s.substring(0, 64);
}

/** Enkel ISO8601 duration-parser (PnDTnHnMnS -> ms) */
export function parseIsoDurationToMs(dur: string | undefined): number | null {
  if (!dur) return null;
  const m = dur.match(/P(?:(\d+)D)?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?)?/);
  if (!m) return null;
  const days = Number(m[1] || 0);
  const hours = Number(m[2] || 0);
  const mins = Number(m[3] || 0);
  const secs = Number(m[4] || 0);
  return ((days * 24 + hours) * 60 + mins) * 60_000 + secs * 1000;
}

// ---------- Factory ----------
export function createMewsClient(overrides: Partial<MewsClientOptions> = {}): MewsClient {
  const baseUrlRaw = (overrides.baseUrl ?? process.env.MEWS_BASE_URL ?? '').toString().trim();
  if (!baseUrlRaw) throw new Error('Missing MEWS_BASE_URL');
  const baseUrl = baseUrlRaw.replace(/\/$/, '');

  const clientToken = (overrides.clientToken ?? process.env.MEWS_CLIENT_TOKEN ?? '').toString().trim();
  if (!clientToken) throw new Error('Missing MEWS_CLIENT_TOKEN');

  const accessToken = (overrides.accessToken ?? process.env.MEWS_ACCESS_TOKEN ?? '').toString().trim();
  if (!accessToken) throw new Error('Missing MEWS_ACCESS_TOKEN');

  const enterpriseId =
    (overrides.enterpriseId ?? process.env.MEWS_ENTERPRISE_ID ?? '').toString().trim() || undefined;

  const clientName = (overrides.clientName ?? process.env.MEWS_CLIENT_NAME ?? 'bno-api')
    .toString()
    .replace(/^"|"$/g, '')
    .trim();

  const hotelTimeZone = (overrides.hotelTimeZone ?? process.env.HOTEL_TIMEZONE ?? 'Europe/Oslo')
    .toString()
    .trim();

  function toLocalYmd(input: string | Date): string {
    if (typeof input === 'string') {
      const s = input.trim();
      if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
      const d = new Date(s);
      if (!Number.isNaN(d.getTime())) {
        const fmt = new Intl.DateTimeFormat('en-CA', {
          timeZone: hotelTimeZone,
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
        });
        return fmt.format(d);
      }
      return s.slice(0, 10);
    }

    const fmt = new Intl.DateTimeFormat('en-CA', {
      timeZone: hotelTimeZone,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
    });
    return fmt.format(input);
  }

  function addDaysYmd(ymd: string, deltaDays: number): string {
    const [y, m, d] = ymd.split('-').map((x) => Number(x));
    const dt = new Date(Date.UTC(y, (m || 1) - 1, d || 1, 0, 0, 0, 0));
    dt.setUTCDate(dt.getUTCDate() + deltaDays);
    const yy = dt.getUTCFullYear();
    const mm = String(dt.getUTCMonth() + 1).padStart(2, '0');
    const dd = String(dt.getUTCDate()).padStart(2, '0');
    return `${yy}-${mm}-${dd}`;
  }

  /** Konverter lokal dato (YYYY-MM-DD eller Date) til "time unit UTC" (midnatt lokal tid i UTC) */
  function toTimeUnitUtc(date: string | Date): string {
    const ymd = toLocalYmd(date);
    const [yy, mm, dd] = ymd.split('-').map((x) => Number(x));
    const utcMidnight = new Date(Date.UTC(yy, (mm || 1) - 1, dd || 1, 0, 0, 0, 0));

    let off = tzOffsetMinutesAt(utcMidnight, hotelTimeZone);
    let candidate = new Date(utcMidnight.getTime() - off * 60_000);
    const off2 = tzOffsetMinutesAt(candidate, hotelTimeZone);
    if (off2 !== off) candidate = new Date(utcMidnight.getTime() - off2 * 60_000);
    return candidate.toISOString();
  }

  async function postJson(path: string, body: any, timeout = 15000) {
    try {
      const cleaned = removeUndefinedRecursive(body);

      // Safe masked log (ikke lek tokens)
      try {
        const safe = { ...(cleaned || {}) };
        if ('ClientToken' in safe) (safe as any).ClientToken = '[MASKED]';
        if ('AccessToken' in safe) (safe as any).AccessToken = '[MASKED]';
        if ('Images' in safe) (safe as any).Images = '[omitted]';
        console.log('MEWS CALL', path, Object.keys(safe || {}).length ? JSON.stringify(safe).slice(0, 1200) : '{}');
      } catch {}

      const data = await axiosWithRetry(
        {
          method: 'post',
          url: path,
          data: cleaned,
          timeout,
          headers: { 'Content-Type': 'application/json' },
        },
        3,
        500,
        true,
      );
      return { data };
    } catch (err: any) {
      const e = new Error(err?.message || 'Request failed');
      (e as any).response = err?.response || null;
      (e as any).mewsResponse =
        err?.mewsResponse ||
        (err?.response
          ? { status: err.response?.status, headers: err.response?.headers, data: err.response?.data }
          : null);
      throw e;
    }
  }

  // ---------- Connector API ----------
  async function fetchAvailability(serviceId: string, first: string | Date, last: string | Date) {
    const url = `${baseUrl}/api/connector/v1/services/getAvailability`;
    const body = {
      ClientToken: clientToken,
      AccessToken: accessToken,
      Client: clientName,
      ServiceId: serviceId,
      FirstTimeUnitStartUtc: toTimeUnitUtc(first),
      LastTimeUnitStartUtc: toTimeUnitUtc(last),
    };
    const resp = await postJson(url, body);
    return resp.data;
  }

  async function fetchCategoriesRaw(serviceId: string) {
    const url = `${baseUrl}/api/connector/v1/resourceCategories/getAll`;
    const resp = await postJson(url, {
      ClientToken: clientToken,
      AccessToken: accessToken,
      Client: clientName,
      ServiceIds: [serviceId],
      Limitation: { Count: 1000 },
    });
    return resp.data?.ResourceCategories || [];
  }

  async function fetchImageUrls(imageIds: string[]) {
    if (!imageIds?.length) return {};
    const url = `${baseUrl}/api/connector/v1/images/getUrls`;
    const payload = {
      ClientToken: clientToken,
      AccessToken: accessToken,
      Client: clientName,
      Images: imageIds.map((id) => ({
        ImageId: id,
        ResizeMode: 'Fit',
        Width: 1200,
        Height: 800,
      })),
    };
    const resp = await postJson(url, payload);
    const out: Record<string, string> = {};
    (resp.data?.ImageUrls || []).forEach((it: any) => {
      if (it?.ImageId && it?.Url) out[it.ImageId] = it.Url;
    });
    return out;
  }

  async function fetchProducts(serviceId: string) {
    const url = `${baseUrl}/api/connector/v1/products/getAll`;
    const resp = await postJson(url, {
      ClientToken: clientToken,
      AccessToken: accessToken,
      Client: clientName,
      ServiceIds: [serviceId],
      Limitation: { Count: 1000 },
    });
    return resp.data?.Products || [];
  }

  async function fetchService(serviceId: string) {
    const url = `${baseUrl}/api/connector/v1/services/getAll`;
    const resp = await postJson(url, {
      ClientToken: clientToken,
      AccessToken: accessToken,
      Client: clientName,
      ServiceIds: [serviceId],
      Limitation: { Count: 10 },
    });
    const arr = resp.data?.Services || [];
    return arr.length ? arr[0] : null;
  }

  async function fetchAvailabilityNamed(serviceId: string, first: string | Date, last: string | Date) {
    const availability = await fetchAvailability(serviceId, first, last);
    const timeUnits: string[] = availability?.TimeUnitStartsUtc ?? availability?.DatesUtc ?? [];

    let rcAvail: any[] = availability?.ResourceCategoryAvailabilities;
    if (!Array.isArray(rcAvail) || !rcAvail.length) {
      const cat = Array.isArray(availability?.CategoryAvailabilities) ? availability.CategoryAvailabilities : [];
      rcAvail = cat.map((c: any) => ({
        ResourceCategoryId: c?.CategoryId,
        TotalAvailableUnitsCount: c?.TotalAvailableUnitsCount,
        Availabilities: c?.Availabilities,
        Adjustments: c?.Adjustments,
      }));
    }

    const categories: any[] = await fetchCategoriesRaw(serviceId);
    const catMap: Record<string, any> = {};
    categories.forEach((c) => (catMap[c.Id] = c));

    const categoryIds: string[] = rcAvail.map((r: any) => r.ResourceCategoryId).filter(Boolean);

    // Hent bilde-assignments (best effort)
    const catImageIds: Record<string, string[]> = {};
    if (categoryIds.length) {
      const url = `${baseUrl}/api/connector/v1/resourceCategoryImageAssignments/getAll`;
      try {
        const resp = await postJson(url, {
          ClientToken: clientToken,
          AccessToken: accessToken,
          Client: clientName,
          ResourceCategoryIds: categoryIds,
          Limitation: { Count: 1000 },
        });
        const assigns: any[] = resp.data?.ResourceCategoryImageAssignments || [];
        assigns.forEach((a) => {
          if (a?.IsActive && a?.CategoryId && a?.ImageId) {
            if (!catImageIds[a.CategoryId]) catImageIds[a.CategoryId] = [];
            if (!catImageIds[a.CategoryId].includes(a.ImageId)) catImageIds[a.CategoryId].push(a.ImageId);
          }
        });
      } catch (err: any) {
        console.warn('fetchAvailabilityNamed: imageAssignments failed', err?.message || err);
      }
    }

    const uniqueImageIds = Array.from(new Set(Object.values(catImageIds).flat()));
    const imageUrlMap = await fetchImageUrls(uniqueImageIds);

    const enriched = rcAvail.map((r: any) => {
      const cat = catMap[r.ResourceCategoryId];
      let name: string | null = null;
      let description: string | null = null;
      let capacity = 0;

      if (cat) {
        if (cat.Names && Object.keys(cat.Names).length) name = cat.Names[Object.keys(cat.Names)[0]];
        else if (cat.ShortNames && Object.keys(cat.ShortNames).length) name = cat.ShortNames[Object.keys(cat.ShortNames)[0]];
        else if (cat.ExternalIdentifier) name = cat.ExternalIdentifier;

        if (cat.Descriptions && Object.keys(cat.Descriptions).length) {
          description = cat.Descriptions[Object.keys(cat.Descriptions)[0]];
        }
        capacity = cat.Capacity || 0;
      }

      const imgIds = catImageIds[r.ResourceCategoryId] || [];
      const images = imgIds.map((id) => imageUrlMap[id]).filter(Boolean);

      return {
        ...r,
        Name: name,
        Description: description,
        Capacity: capacity,
        Image: images[0] || null,
        Images: images,
      };
    });

    return { TimeUnitStartsUtc: timeUnits, ResourceCategoryAvailabilities: enriched };
  }

  // ---------- Customers ----------
  async function findOrCreateCustomer(customer: any) {
    if (!customer) throw new Error('Missing customer');

    const email = String(customer.email || customer.Email || '').trim().toLowerCase();
    if (!email) throw new Error('Customer email missing');

    let first = sanitizeName(customer.firstName || customer.FirstName || 'Guest');
    let last = sanitizeName(customer.lastName || customer.LastName || 'Guest');
    const nat = String(customer.nationality || customer.Nationality || '').trim().toUpperCase();
    const cor = String(customer.countryOfResidence || customer.CountryOfResidence || '').trim().toUpperCase();
    const phone = String(customer.phone || customer.Phone || '').trim() || undefined;

    // 1) prøv å finne
    try {
      const urlGetAll = `${baseUrl}/api/connector/v1/customers/getAll`;
      const resp = await postJson(
        urlGetAll,
        {
          ClientToken: clientToken,
          AccessToken: accessToken,
          Client: clientName,
          Emails: [email],
          Extent: { Customers: true },
          Limitation: { Count: 10 },
        },
        15000,
      );

      const found = Array.isArray(resp?.data?.Customers)
        ? resp.data.Customers.find((c: any) => String(c?.Email || '').toLowerCase() === email)
        : null;

      if (found?.Id) return found.Id;
    } catch {}

    // 2) add (med noen retries hvis navn ikke godtas)
    async function tryAdd(firstName: string, lastName: string): Promise<string> {
      const urlAdd = `${baseUrl}/api/connector/v1/customers/add`;
      const addBody: any = {
        ClientToken: clientToken,
        AccessToken: accessToken,
        Client: clientName,
        OverwriteExisting: true,
        Customers: [
          {
            FirstName: firstName || 'Guest',
            LastName: lastName || 'Guest',
            Email: email,
            Phone: phone,
            NationalityCode: nat || undefined,
            Address: cor ? { CountryCode: cor } : undefined,
          },
        ],
      };

      const resp = await postJson(urlAdd, addBody, 15_000);
      const id =
        (Array.isArray(resp?.data?.CustomerIds) && resp.data.CustomerIds[0]) ||
        (Array.isArray(resp?.data?.Customers) && resp.data.Customers[0]?.Id) ||
        resp?.data?.CustomerId ||
        resp?.data?.Id ||
        resp?.data?.Customer?.Id;

      if (id) return id;
      throw new Error(`Unexpected response from customers/add`);
    }

    try {
      return await tryAdd(first, last);
    } catch (eA: any) {
      const msgA = String(eA?.response?.data?.Message || eA?.message || eA).toLowerCase();
      if (!msgA.includes('invalid last')) throw eA;

      try {
        return await tryAdd('Guest', 'Guest');
      } catch (eB: any) {
        const msgB = String(eB?.response?.data?.Message || eB?.message || eB).toLowerCase();
        if (msgB.includes('invalid last')) {
          return await tryAdd('Guest', `Guest-${Date.now()}`);
        }
        throw eB;
      }
    }
  }

  // ---------- Reservations (create) ----------
  async function createReservation(p: any) {
    if (!p) throw new Error('createReservation: missing payload');

    try {
      const rooms = Array.isArray(p.Rooms) && p.Rooms.length ? p.Rooms : [];
      const firstRoom = rooms[0] || {};
      const qty = Math.max(1, Number(firstRoom.Quantity || 1));

      const personCounts = (firstRoom.Occupancy || []).map((o: any) => ({
        AgeCategoryId: o.AgeCategoryId,
        Count: Number(o.PersonCount || 0),
      }));

      const baseReservation: any = {
        Identifier: p.ClientReference || `bno-${Date.now()}`,
        State: p.State || 'Optional',
        StartUtc: firstRoom.StartUtc,
        EndUtc: firstRoom.EndUtc,
        CheckRateApplicability: false,
        ReleasedUtc: null,
        CustomerId: p.CustomerId || p.CustomerIdFromFind || undefined,
        RequestedCategoryId: firstRoom.RoomCategoryId || firstRoom.ResourceCategoryId || undefined,
        RateId: firstRoom.RateId || undefined,
        TravelAgencyId: null,
        TimeUnitAmount: null,
        PersonCounts: personCounts,
        TimeUnitPrices: [],
      };

      const reservations = Array.from({ length: qty }).map((_, i) => ({
        ...baseReservation,
        Identifier: `${baseReservation.Identifier}-${i + 1}`,
      }));

      const body = {
        ClientToken: clientToken,
        AccessToken: accessToken,
        Client: clientName,
        ServiceId: p.ServiceId || undefined,
        SendConfirmationEmail: p.SendConfirmationEmail === true,
        CheckRateApplicability: false,
        Reservations: reservations,
      };

      const url = `${baseUrl}/api/connector/v1/reservations/add`;
      const resp = await postJson(url, body, 20_000);
      if (resp?.data) return resp.data;
      throw new Error('Empty response from reservations/add');
    } catch (err: any) {
      const e = new Error('createReservation failed');
      (e as any).mewsResponse = err?.mewsResponse || err?.response || err?.message || err;
      throw e;
    }
  }

  async function createProductServiceOrders(serviceId: string, reservationId: string, orders: any[]) {
    if (!serviceId) throw new Error('Missing serviceId');
    if (!reservationId) throw new Error('Missing reservationId');
    if (!Array.isArray(orders) || orders.length === 0) return null;

    const url = `${baseUrl}/api/connector/v1/productServiceOrders/add`;
    const payload = {
      ClientToken: clientToken,
      AccessToken: accessToken,
      Client: clientName,
      ServiceId: serviceId,
      ProductServiceOrders: orders.map((o) => {
        const out: any = {
          ProductId: o.ProductId || o.productId,
          ReservationId: reservationId,
          Quantity: Number(o.Quantity || o.quantity || o.Count || 0),
        };
        if (o.Price != null) {
          out.Price = { Amount: Number(o.Price), Currency: o.Currency || undefined };
        }
        return out;
      }),
    };

    try {
      const resp = await postJson(url, payload, 20_000);
      return resp.data;
    } catch (err: any) {
      const e = new Error('createProductServiceOrders failed');
      (e as any).mewsResponse = err?.mewsResponse || err?.response || err?.message || err;
      throw e;
    }
  }

  // ---------- Resources ----------
  async function fetchResources(serviceId: string | string[]) {
    const serviceIds = Array.isArray(serviceId)
      ? serviceId.map((s) => String(s).trim()).filter(Boolean)
      : [String(serviceId).trim()].filter(Boolean);

    const url = `${baseUrl}/api/connector/v1/resources/getAll`;
    const resp = await postJson(url, {
      ClientToken: clientToken,
      AccessToken: accessToken,
      Client: clientName,
      ServiceIds: serviceIds,
      Limitation: { Count: 1000 },
    });
    return resp.data?.Resources || [];
  }

  // ---------- Order items ----------
  async function fetchOrderItemsForCleaningRange(
    serviceId: string | string[],
    startDate: string | Date,
    endDate: string | Date,
  ) {
    const serviceIds = Array.isArray(serviceId)
      ? serviceId.map((s) => String(s).trim()).filter(Boolean)
      : [String(serviceId).trim()].filter(Boolean);

    if (!serviceIds.length) throw new Error('fetchOrderItemsForCleaningRange: missing serviceId(s)');

    const url = `${baseUrl}/api/connector/v1/orderItems/getAll`;

    const startYmd = toLocalYmd(startDate);
    const endYmd = toLocalYmd(endDate);

    const items: any[] = [];
    const seen = new Set<string>();

    const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));

    async function fetchInterval(startUtcIso: string, endUtcIso: string, parts = 1, maxParts = 24) {
      const startMs = Date.parse(startUtcIso);
      const endMs = Date.parse(endUtcIso);
      if (!Number.isFinite(startMs) || !Number.isFinite(endMs) || endMs <= startMs) return;

      const totalMs = endMs - startMs;
      const partMs = Math.floor(totalMs / parts);

      for (let p = 0; p < parts; p++) {
        const subStartMs = startMs + p * partMs;
        const subEndMs = p === parts - 1 ? endMs : startMs + (p + 1) * partMs;

        const subStart = new Date(subStartMs);
        const subEnd = new Date(subEndMs);

        const body: any = {
          ClientToken: clientToken,
          AccessToken: accessToken,
          Client: clientName,
          EnterpriseId: enterpriseId,
          ServiceIds: serviceIds,
          ConsumedUtc: { StartUtc: subStart.toISOString(), EndUtc: subEnd.toISOString() },
          Limitation: { Count: 1000 },
        };

        try {
          await sleep(150);
          const resp = await postJson(url, body, 20_000);
          const data = resp.data || {};
          const pageItems: any[] = Array.isArray(data.OrderItems)
            ? data.OrderItems
            : Array.isArray(data.Items)
            ? data.Items
            : [];

          for (const it of pageItems) {
            const id = it?.Id ? String(it.Id) : null;
            if (id && seen.has(id)) continue;
            if (id) seen.add(id);
            items.push(it);
          }
        } catch (err: any) {
          const msg = String(err?.mewsResponse?.data?.Message || err?.message || '').toLowerCase();
          const isLimitation =
            msg.includes('limitation') ||
            msg.includes('limitation count') ||
            msg.includes('must be in range') ||
            msg.includes('out of range');

          if (isLimitation && parts * 2 <= maxParts) {
            console.warn(`orderItems/getAll limitation -> subdividing (${parts * 2} parts)`);
            await fetchInterval(subStart.toISOString(), subEnd.toISOString(), 2, maxParts);
          } else {
            console.error('orderItems/getAll failed', err?.mewsResponse || err?.message || err);
          }
        }
      }
    }

    let cursorYmd = startYmd;
    let safety = 0;

    while (cursorYmd <= endYmd) {
      safety++;
      if (safety > 4000) throw new Error('fetchOrderItemsForCleaningRange: safety stop (too many days)');

      const nextYmd = addDaysYmd(cursorYmd, 1);

      const startTU = toTimeUnitUtc(cursorYmd);
      const endTU = toTimeUnitUtc(nextYmd);

      await fetchInterval(startTU, endTU, 1, 24);

      cursorYmd = nextYmd;
    }

    console.log(`DEBUG: aggregated orderItems count=${items.length} for serviceIds=${serviceIds.join(',')}`);
    return items;
  }

  // ---------- Internals for date chunking ----------
  function parseDateOnlyUtc(d: string | Date): Date {
    const ymd = toLocalYmd(d);
    const [y, m, day] = ymd.split('-').map((x) => Number(x));
    return new Date(Date.UTC(y, (m || 1) - 1, day || 1, 0, 0, 0, 0));
  }
  function addDaysUtc(d: Date, days: number): Date {
    const out = new Date(d.getTime());
    out.setUTCDate(out.getUTCDate() + days);
    return out;
  }
  function daysInUtcMonth(year: number, monthIndex0: number): number {
    return new Date(Date.UTC(year, monthIndex0 + 1, 0)).getUTCDate();
  }
  function addMonthsUtc(date: Date, months: number): Date {
    const y = date.getUTCFullYear();
    const m = date.getUTCMonth();
    const d = date.getUTCDate();
    const targetMonth = m + months;
    const tmp = new Date(Date.UTC(y, targetMonth, 1, 0, 0, 0, 0));
    const dim = daysInUtcMonth(tmp.getUTCFullYear(), tmp.getUTCMonth());
    tmp.setUTCDate(Math.min(d, dim));
    return tmp;
  }
  function minDate(a: Date, b: Date): Date {
    return a.getTime() <= b.getTime() ? a : b;
  }

  // ---------- Reservations (FIX: schema for getAll/2023-06-06) ----------
  async function fetchReservationsForCleaningRangeSingle(
    serviceId: string,
    startTU: string,
    endExclusiveTU: string,
  ) {
    const url = `${baseUrl}/api/connector/v1/reservations/getAll/2023-06-06`;

    const rawReservations: any[] = [];
    const seenIds = new Set<string>();

    let cursor: string | null = null;
    let safety = 0;

    while (true) {
      safety++;
      if (safety > 50) {
        console.warn('fetchReservationsForCleaningRangeSingle: safety stop (too many pages)');
        break;
      }

      // VIKTIG:
      // - Bruk EnterpriseIds (array) (ikke EnterpriseId)
      // - Ikke send Extent her (den ga 400 i ditt tilfelle)
      // - Bruk Limitation.Cursor for paging
      const body: any = {
        ClientToken: clientToken,
        AccessToken: accessToken,
        Client: clientName,

        EnterpriseIds: enterpriseId ? [enterpriseId] : undefined,
        ServiceIds: [serviceId],
        States: ['Confirmed', 'Started', 'Processed'],

        ScheduledEndUtc: {
          StartUtc: startTU,
          EndUtc: endExclusiveTU,
        },

        Limitation: {
          Count: 1000,
          Cursor: cursor || undefined,
        },
      };

      const resp = await postJson(url, body, 20_000);
      const data = resp.data || {};

      const page: any[] = Array.isArray(data.Reservations) ? data.Reservations : [];
      for (const r of page) {
        const id = r?.Id ? String(r.Id) : '';
        if (id) {
          if (seenIds.has(id)) continue;
          seenIds.add(id);
        }
        rawReservations.push(r);
      }

      const nextCursor = data.Cursor ? String(data.Cursor) : null;
      if (!nextCursor) break;
      if (nextCursor === cursor) break;
      if (!page.length) break;

      cursor = nextCursor;
    }

    // failsafe: filtrer i intervallet
    const startMs = Date.parse(startTU);
    const endMs = Date.parse(endExclusiveTU);

    return rawReservations.filter((r: any) => {
      const scheduledEnd = r?.ScheduledEndUtc || r?.EndUtc || r?.End?.Utc || null;
      const t = scheduledEnd ? Date.parse(String(scheduledEnd)) : NaN;
      return Number.isFinite(t) && t >= startMs && t < endMs;
    });
  }

  async function fetchReservationsForCleaningRange(
    serviceId: string,
    startDate: string | Date,
    endDate: string | Date,
  ) {
    const start = parseDateOnlyUtc(startDate);
    const endInclusive = parseDateOnlyUtc(endDate);

    if (Number.isNaN(start.getTime()) || Number.isNaN(endInclusive.getTime())) {
      throw new Error('fetchReservationsForCleaningRange: invalid start/end dates');
    }
    if (start.getTime() > endInclusive.getTime()) {
      throw new Error('fetchReservationsForCleaningRange: startDate is after endDate');
    }

    const endExclusive = addDaysUtc(endInclusive, 1);

    const byId = new Map<string, any>();
    let cursor = start;
    let safety = 0;

    while (cursor.getTime() < endExclusive.getTime()) {
      safety++;
      if (safety > 60) throw new Error('fetchReservationsForCleaningRange: safety stop (too many chunks)');

      const chunkEndExclusive = minDate(addMonthsUtc(cursor, 3), endExclusive);

      const startTU = toTimeUnitUtc(cursor);
      const endExclusiveTU = toTimeUnitUtc(chunkEndExclusive);

      const rows = await fetchReservationsForCleaningRangeSingle(serviceId, startTU, endExclusiveTU);
      for (const r of rows || []) {
        const id = r?.Id ? String(r.Id) : null;
        if (!id) continue;
        if (!byId.has(id)) byId.set(id, r);
      }

      cursor = chunkEndExclusive;
    }

    const reservations = Array.from(byId.values());

    // Best effort: hent orderItems separat og forsøk å henge dem på reservasjonene
    try {
      const orderItems = await fetchOrderItemsForCleaningRange(serviceId, startDate, endDate);

      const reservationLookup = new Map<string, string>();
      const orderIdToReservationId = new Map<string, string>();

      const norm = (v: any): string | null => (v === null || v === undefined ? null : String(v).trim().toLowerCase());

      function getReservationKey(r: any): string | null {
        const rid = r?.Id || r?.ReservationId || r?.ExternalIdentifier || r?.Identifier || r?.Number;
        return rid ? String(rid) : null;
      }

      for (const r of reservations) {
        const rid = getReservationKey(r);
        if (!rid) continue;

        const addKey = (k: any) => {
          const s = norm(k);
          if (!s) return;
          if (!reservationLookup.has(s)) reservationLookup.set(s, String(rid));
        };

        addKey(rid);
        addKey(r?.Id);
        addKey(r?.ReservationId);
        addKey(r?.ExternalIdentifier);
        addKey(r?.Identifier);
        addKey(r?.Number);

        // Bygg mapping for order-id felt (hvis de finnes i reservation-objektet)
        const candOrderIds = [r?.OrderId, r?.ServiceOrderId, r?.Order?.Id, r?.Order?.OrderId];
        for (const oid of candOrderIds) {
          const o = oid ? String(oid) : null;
          if (o && !orderIdToReservationId.has(o)) orderIdToReservationId.set(o, String(rid));
        }
      }

      const itemsByRes = new Map<string, any[]>();

      function resolveReservationIdFromItem(it: any): string | null {
        const direct = [
          it?.ReservationId,
          it?.Reservation?.Id,
          it?.Reservation?.ReservationId,
          it?.Reservation?.ExternalIdentifier,
        ];
        for (const d of direct) {
          const dn = norm(d);
          if (dn && reservationLookup.has(dn)) return reservationLookup.get(dn)!;
        }

        const orderCandidates = [it?.ServiceOrderId, it?.OrderId, it?.Order?.Id, it?.Order?.OrderId, it?.Order?.ServiceOrderId];
        for (const oc of orderCandidates) {
          if (!oc) continue;
          const mapped = orderIdToReservationId.get(String(oc));
          if (mapped) return mapped;
        }

        if (it?.ExternalIdentifier) {
          const e = norm(it.ExternalIdentifier);
          if (e && reservationLookup.has(e)) return reservationLookup.get(e)!;
        }

        return null;
      }

      for (const it of orderItems || []) {
        const rid = resolveReservationIdFromItem(it);
        if (!rid) continue;
        if (!itemsByRes.has(rid)) itemsByRes.set(rid, []);
        itemsByRes.get(rid)!.push(it);
      }

      for (const r of reservations) {
        const rid = getReservationKey(r);
        if (!rid) continue;
        const items = itemsByRes.get(rid) || [];
        if (!items.length) continue;

        const existing: any[] = Array.isArray(r?.Items) ? r.Items : Array.isArray(r?.OrderItems) ? r.OrderItems : [];
        const merged = existing.length ? [...existing, ...items] : items;

        (r as any).Items = merged;
        (r as any).OrderItems = merged;
      }
    } catch (e: any) {
      console.warn('fetchReservationsForCleaningRange: orderItems attach failed (non-fatal)', e?.message || e);
    }

    return reservations;
  }

  // alias
  const fetchSpaces = fetchResources;

  // ---------- Linen aggregator ----------
  function buildLinenCountMapFromOrderItems(
    items: any[],
    linenProducts: Record<string, { personsPerUnit: number; name: string }>,
    soToRes?: Record<string, string> | Map<string, string>,
  ): Record<string, number> {
    const result: Record<string, number> = {};

    const linenByName = Object.values(linenProducts).map((lp) => ({
      name: (lp.name || '').toLowerCase(),
      personsPerUnit: lp.personsPerUnit,
    }));

    const soLookup = (() => {
      if (!soToRes) return null;
      if (soToRes instanceof Map) return soToRes;
      const m = new Map<string, string>();
      for (const [k, v] of Object.entries(soToRes)) m.set(String(k), String(v));
      return m;
    })();

    const getProductIdFromItem = (it: any): string | null => {
      if (!it) return null;
      if (it.ProductId) return String(it.ProductId);
      if (it.Product?.Id) return String(it.Product.Id);
      if (it.Product?.ProductId) return String(it.Product.ProductId);
      if (it.Data?.ProductId) return String(it.Data.ProductId);
      if (it.Data?.Product?.Id) return String(it.Data.Product.Id);
      if (it.Data?.Product?.ProductId) return String(it.Data.Product.ProductId);
      return null;
    };

    const resolveReservationId = (it: any): string | null => {
      const direct =
        it.ReservationId || it.Reservation?.Id || it.Reservation?.ReservationId || it.Reservation?.ExternalIdentifier;
      if (direct) return String(direct);

      const soId =
        it.ServiceOrderId ||
        it.ServiceOrder?.Id ||
        it.ServiceOrder?.ServiceOrderId ||
        it.Order?.ServiceOrderId ||
        it.Order?.ServiceOrder?.Id;

      if (soId && soLookup) {
        const mapped = soLookup.get(String(soId));
        if (mapped) return String(mapped);
      }

      if (soId) return String(soId);

      const oid = it.OrderId || it.Order?.Id || it.Order?.OrderId;
      return oid ? String(oid) : null;
    };

    for (const it of items || []) {
      const rid = resolveReservationId(it);
      if (!rid) continue;

      const productIdRaw = getProductIdFromItem(it);
      let lp =
        productIdRaw && linenProducts[productIdRaw.toLowerCase()]
          ? linenProducts[productIdRaw.toLowerCase()]
          : undefined;

      const nameRaw =
        (it.Name ||
          it.ProductName ||
          it.Product?.Name ||
          it.Data?.Name ||
          it.Data?.Product?.Name ||
          it.Data?.Value?.Name ||
          it.Data?.Value?.Product?.Name) ||
        '';

      const nameLower = String(nameRaw || '').toLowerCase();

      if (!lp && nameLower) {
        for (const p of linenByName) {
          if (p.name && nameLower.includes(p.name)) {
            lp = { personsPerUnit: p.personsPerUnit, name: nameRaw };
            break;
          }
        }
      }

      if (!lp && nameLower && /(sengetøy|sengetoy|håndkl|handkl|bed linen|linen)/i.test(nameLower)) {
        let personsPerUnit = 1;
        const m = nameLower.match(/(\d+)\s*(pers|personer|person|p\b)/);
        if (m) {
          const parsed = Number(m[1]);
          if (!Number.isNaN(parsed) && parsed > 0) personsPerUnit = parsed;
        }
        lp = { personsPerUnit, name: nameRaw || 'Linen' };
      }

      if (!lp) continue;

      const quantity =
        Number(
          it.UnitCount ??
            it.Quantity ??
            it.Count ??
            it.UnitAmount?.Count ??
            it.Data?.UnitCount ??
            it.Data?.Quantity ??
            it.Data?.Count ??
            1,
        ) || 1;

      const add = quantity * (lp.personsPerUnit || 1);
      result[rid] = (result[rid] || 0) + add;
    }

    return result;
  }

  return {
    toTimeUnitUtc,
    parseIsoDurationToMs,

    fetchAvailability,
    fetchAvailabilityNamed,
    fetchCategoriesRaw,
    fetchProducts,
    fetchImageUrls,
    fetchService,

    findOrCreateCustomer,
    createReservation,
    createProductServiceOrders,

    fetchResources,
    fetchSpaces,

    fetchOrderItemsForCleaningRange,
    fetchReservationsForCleaningRange,

    buildLinenCountMapFromOrderItems,
  };
}

// ---------- Default client ----------
const defaultClient = createMewsClient();

export const toTimeUnitUtc = defaultClient.toTimeUnitUtc;
export const fetchAvailability = defaultClient.fetchAvailability;
export const fetchAvailabilityNamed = defaultClient.fetchAvailabilityNamed;
export const fetchCategoriesRaw = defaultClient.fetchCategoriesRaw;
export const fetchProducts = defaultClient.fetchProducts;
export const fetchImageUrls = defaultClient.fetchImageUrls;
export const fetchService = defaultClient.fetchService;

export const findOrCreateCustomer = defaultClient.findOrCreateCustomer;
export const createReservation = defaultClient.createReservation;
export const createProductServiceOrders = defaultClient.createProductServiceOrders;

export const fetchResources = defaultClient.fetchResources;
export const fetchSpaces = defaultClient.fetchSpaces;

export const fetchOrderItemsForCleaningRange = defaultClient.fetchOrderItemsForCleaningRange;
export const fetchReservationsForCleaningRange = defaultClient.fetchReservationsForCleaningRange;

export const buildLinenCountMapFromOrderItems = defaultClient.buildLinenCountMapFromOrderItems;

export default defaultClient;
